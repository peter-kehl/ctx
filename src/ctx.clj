(ns ctx
  (:require [clojure.string]))

;CONVENTIONS
;tagged reader handler functions have name starting with "reader-tag-"

(def ^:dynamic ^:private *collected-symbols* false) ;Map: user's symbol->`++ or `--. Assoc fails for false. Don't initialise to nil, because that proceeds silently, hiding an error. Used only by tag readers. Don't use it in macros, because macros are expanded only after processing any tags.
(def ^:private ++ `++) (def ^:private -- `--)
(defn ^:private collect-symbol [action-sym user-sym]
  {:pre[(symbol? action-sym) (symbol? user-sym) *collected-symbols*
    #_TODO-picking-mode]}
  (when-not (*collected-symbols* user-sym) ;We collect from the bottom up. If already collected, that deeper occurrence hides any upper symbols with the same name.
              (set! *collected-symbols* (assoc *collected-symbols* user-sym action-sym))))
(def reader-tag-++ (partial collect-symbol ++))
(def reader-tag--- (partial collect-symbol --))

(def scope? map?) ;TODO
(defn export-scope [symbols captured]
  {:pre [(seq? symbols) (every? symbol? symbols) (map? captured)]
   :post [(scope? %)]}
  "TODO")

(def ^:dynamic ^:private ctx-strict-tags false)
(alter-var-root  (var ctx-strict-tags) (fn [_] false))
(defmacro non-existing-var []
  '(ns-resolve *ns* non-existing-var))

;TODO instead of #ctx/bottom (ctx/level), allow: #ctx/bottom ctx/level
; where ctx/level is still a macro, but reader-tag-bottom adds parens. That makes
; typing easier for the user. Don't (def bottom) as a variable, because then
; we'd lose parsing protection if the user doesn't prefix it with #ctx/bottom.
; If we use a macro, and the user forgets prefix #ctx/bottom, then
; using just ctx/level (without parens) generates a parser error - which protects the user.
; You can call this at a file's top level only. TODO optional - worthwhile?
(defn reader-tag-picking [mode-macro-or-call]
  {:pre[(or (= mode-macro-or-call `tags) (= (first mode-macro-or-call) `tags))]}
  (set! *collected-symbols* {}))
;(defmacro tags [] '(def ^:private ctx-strict-tags true)) ;not with a backtick `, but with a simple quote. We want ctx-strict-tags to be in user's namespace, not in ctx/ - so that code generated by (scope) macro can access it - TODO how to access it?

(def ^:private reader-tag-start-token ::reader-tag-start-token)
(def ^:private reader-tag-bottom-token ::reader-tag-bottom-token)
; Clojure processes all tagged reader elements in the whole file before any macros.
; Hence, this will be run by the parser before macro expansion of its enclosing (scope ...).
; It injecs any collected symbols to the following call of (level) macro.
; It resets the symbol collector. Not private, so that it works from data_readers.clj.
; If the Clojure language scope contains several bound symbols with the same name (any deeper one shadowing the outer one), then this captures only the leaf binding. That's even if you apply #ctx/++ on any of the higher symbols. #ctx/++ only registers the symbol name, but not its level. (It could register the symbol binding's unique identifier (hashcode), but at the bottom level it can't access values of the higher symbols anyway.)
; Alternative naming could be #ctx/end (ctx/scope). It would involve one more version of (scope) macro with 0 arity. It could
; be confusing: It would work as intended - as an end of the recorded lexical scope - if the innermost bound symbols come from (let[...]). However, if the innermost bound symbols come from (letfn[...]), then this #ctx/end (ctx/scope) wouldn't be at the end of the recorded lexical scope, because then the available lexical scope includes any further functions defined in that (letfn[...]).
(defn reader-tag-bottom "Capture a scope bottom. Don't call directly. See level()." [level-macro-or-call]
  {:pre [(list? level-macro-or-call) (= (first level-macro-or-call) `level) (= (count level-macro-or-call) 2)
    *collected-symbols*]}
  (try
    (list `level reader-tag-bottom-token)
    (finally (set! *collected-symbols* {})))) ;TODO if strict, set to false

(defmacro level "Use within (scope ...) to indicate the bottom of the scope. Prefix it with #ctx/bottom. Hence call it as: #ctx/bottom (ctx/level). You must have exactly one #ctx/bottom (ctx/level) per one #ctx/start (ctx/scope...). Don't pass any token parameter, it gets added behind the scenes."
  [reader-tag-token]
  {:pre[]} ;Don't use/validate *collected-symbols*, because when processing macros, *collected-symbols* reflects only the last scope in the file.
  (let [symbols (if &env (keys &env) ())
        captured-at-top-symbol (->> symbols (filter #(clojure.string/starts-with? (str %) "ctx-captured-at-top")) first)]
      `(export-scope ('~@symbols) ~captured-at-top-symbol)))

(defn reader-tag-start "Capture a scope start. Required with #ctx/strict #ctx/mode, otherwise optional. Don't call directly. See scope()." [[action & params :as scope-macro-call]]
  {:pre [(list? scope-macro-call) (= action `scope)
    (false? *collected-symbols*)]}
  `(scope @~params reader-tag-start-token))

;TODO use:
(defrecord CapturedAtTheTop [scope-name symbols collected-symbols])

; TODO Representing the "entry" function in the scope. And/or: implement IFn.
; #
(def ^:private capture-modes #{:all :specified})

; TODO inherit & multiple inheritance. "Child" scopes contain all symbols from all their parents. Any later parent shadows the same symbols from earlier parents.
(defmacro scope "Declare (an outer boundary of) a new scope. When in #ctx/strict #ctx/mode, prefix this macro call with #ctx/start and call it as: #ctx/start (ctx/scope ...). Beware that (ctx/scope...) needs well-suited code to return a captured scope. Common practice is to have (let[...]) or (letfn[...]) inside (ctx/scope), and return value of #ctx/bottom (ctx/level). Parameter `mode` is optional and it defaults to :all. Pass one or more forms. (Don't append any token parameter, it gets added behind the scenes.)"
  ([scope-name form] `(scope ~scope-name :all ~form))
  ([scope-name capture-mode form] `(scope ~scope-name () ~capture-mode ~form))
  ([scope-name parents capture-mode & forms-and-reader-tag-token]
  {:pre [;TODO together with collected tagged symbols: (= reader-tag-token reader-tag-start-token)
         (symbol? scope-name) *collected-symbols*
         (seq? parents) (capture-modes capture-mode)]}
  (let [forms "TODO minus tag collect, if any"
        symbols (if &env (keys &env) ())]
    `(let [ctx-captured-at-top# {
      `scope-name scope-name
      `symbols ('~@symbols)
      `collected-symbols *collected-symbols*
      }]
     ~@forms))))
  ;TODO to tag reader: (finally (set! *collected-symbols* false))

;TODO We need to register tag readers *before* the file is loaded. Investigate data_readers.clj. See https://clojure.org/reference/reader#tagged_literals
(set! *data-readers* (assoc *data-readers*
      'ctx/picking reader-tag-picking
      'ctx/start reader-tag-start
      'ctx/++ reader-tag-++
      'ctx/-- reader-tag---
      'ctx/bottom reader-tag-bottom
      ))
